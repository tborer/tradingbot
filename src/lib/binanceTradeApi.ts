import crypto from 'crypto';
import prisma from '@/lib/prisma';
import { autoTradeLogger } from '@/lib/autoTradeLogger';

interface BinanceOrderParams {
  symbol: string;
  side: 'BUY' | 'SELL';
  type: 'MARKET' | 'LIMIT';
  quantity: number;
  price?: number;
  timeInForce?: 'GTC' | 'IOC' | 'FOK';
  newClientOrderId?: string;
  newOrderRespType?: 'ACK' | 'RESULT' | 'FULL';
}

interface BinanceCredentials {
  apiKey: string;
  secretKey: string;
}

/**
 * Get Binance API credentials for a user
 */
export async function getBinanceCredentials(userId: string): Promise<BinanceCredentials | null> {
  try {
    const settings = await prisma.settings.findUnique({
      where: { userId }
    });

    if (!settings) {
      autoTradeLogger.log(`No settings found for user ${userId}`);
      return null;
    }

    if (!settings.binanceApiKey || !settings.binanceApiSecret) {
      autoTradeLogger.log(`Binance API credentials not configured for user ${userId}`);
      return null;
    }

    return {
      apiKey: settings.binanceApiKey,
      secretKey: settings.binanceApiSecret
    };
  } catch (error) {
    autoTradeLogger.log(`Error retrieving Binance credentials: ${error.message}`);
    console.error('Error retrieving Binance credentials:', error);
    return null;
  }
}

/**
 * Generate HMAC SHA256 signature for Binance API
 * 
 * This function creates a signature by hashing the query string with the secret key
 * according to Binance API specifications:
 * 1. Take the query string (e.g., "symbol=BTCUSDT&side=BUY&type=MARKET&quantity=0.01&timestamp=1678886400000")
 * 2. Create an HMAC SHA256 hash using the secret key
 * 3. Return the hex-encoded hash as the signature
 * 
 * The signature is then appended to the query string as &signature=<hash>
 */
function generateSignature(queryString: string, secretKey: string): string {
  autoTradeLogger.log('Generating signature for Binance API', {
    queryStringLength: queryString.length,
    secretKeyLength: secretKey ? secretKey.length : 0,
    timestamp: new Date().toISOString()
  });
  
  // Log the exact query string being signed (for debugging)
  autoTradeLogger.log('Query string for signature generation', {
    queryString: queryString,
    timestamp: new Date().toISOString()
  });
  
  return crypto
    .createHmac('sha256', secretKey)
    .update(queryString)
    .digest('hex');
}

/**
 * Create a new order on Binance
 * 
 * This function formats the request according to Binance API specifications:
 * - Required parameters: symbol, side, type, quantity, timestamp
 * - Signature is generated using HMAC SHA256 on the query string
 * - API key is sent in the X-MBX-APIKEY header
 * - The request URL format is: https://api.binance.us/api/v3/order?symbol=BTCUSDT&side=BUY&type=MARKET&quantity=0.01&timestamp=1678886400000&signature=<signature>
 * - For test orders, the URL is: https://api.binance.us/api/v3/order/test?symbol=BTCUSDT&side=BUY&type=MARKET&quantity=0.01&timestamp=1678886400000&signature=<signature>
 * 
 * The signature is generated by:
 * 1. Creating a query string with all parameters (e.g., "symbol=BTCUSDT&side=BUY&type=MARKET&quantity=0.01&timestamp=1678886400000")
 * 2. Generating an HMAC SHA256 hash of this string using the secret key
 * 3. Appending the signature to the query string
 */
export async function createBinanceOrder(
  userId: string,
  params: BinanceOrderParams,
  testMode: boolean = false,
  useTestEndpoint: boolean = false
): Promise<any> {
  // Generate a request ID for tracking
  const requestId = `binance_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  
  try {
    // DETAILED LOGGING: Function Parameters - Log all parameters received by the function
    autoTradeLogger.log(`[${requestId}] createBinanceOrder FUNCTION PARAMETERS`, {
      userId,
      params: JSON.stringify(params),
      paramsObject: params, // Log the actual object for better inspection
      testMode,
      useTestEndpoint,
      timestamp: new Date().toISOString()
    });
    
    // Log the exact format required by Binance API
    autoTradeLogger.log(`[${requestId}] BINANCE API REQUIRED FORMAT`, {
      requiredParams: ['symbol', 'side', 'type', 'quantity', 'timestamp'],
      signatureFormat: "HMAC SHA256 signature of 'symbol=X&side=Y&type=Z&quantity=Q&timestamp=T'",
      headerRequired: "X-MBX-APIKEY header with API key",
      timestamp: new Date().toISOString()
    });
    
    // Log values to console for debugging
    console.log(`[${requestId}] createBinanceOrder debug values:`, {
      userId,
      symbol: params.symbol,
      side: params.side,
      type: params.type,
      quantity: params.quantity,
      timestamp: new Date().toISOString()
    });

    // Comprehensive input validation
    if (!userId) {
      const error = new Error('Missing userId parameter');
      autoTradeLogger.log(`[${requestId}] Validation error in createBinanceOrder: Missing userId`, { 
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      throw error;
    }

    if (!params) {
      const error = new Error('Missing params object');
      autoTradeLogger.log(`[${requestId}] Validation error in createBinanceOrder: Missing params`, { 
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      throw error;
    }

    // Validate all required parameters
    const requiredParams = ['symbol', 'side', 'type'];
    for (const param of requiredParams) {
      if (!params[param]) {
        const error = new Error(`Missing required parameter: ${param}`);
        autoTradeLogger.log(`[${requestId}] Validation error in createBinanceOrder: Missing ${param}`, { 
          params: JSON.stringify(params),
          stack: error.stack,
          timestamp: new Date().toISOString()
        });
        throw error;
      }
    }
    
    // Validate quantity
    if (!params.quantity || isNaN(params.quantity) || params.quantity <= 0) {
      const error = new Error(`Invalid quantity parameter: ${params.quantity}`);
      autoTradeLogger.log(`[${requestId}] Validation error in createBinanceOrder: Invalid quantity`, { 
        quantity: params.quantity,
        quantityType: typeof params.quantity,
        isNaN: isNaN(params.quantity),
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      throw error;
    }
    
    // Validate price for LIMIT orders
    if (params.type === 'LIMIT' && (!params.price || isNaN(params.price) || params.price <= 0)) {
      const error = new Error(`Invalid price parameter for LIMIT order: ${params.price}`);
      autoTradeLogger.log(`[${requestId}] Validation error in createBinanceOrder: Invalid price for LIMIT order`, { 
        price: params.price,
        priceType: typeof params.price,
        isNaN: isNaN(params.price),
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
      throw error;
    }

    // Get credentials
    const credentials = await getBinanceCredentials(userId);
    if (!credentials) {
      const error = new Error('Binance API credentials not configured');
      autoTradeLogger.log('Credentials error in createBinanceOrder', { 
        userId,
        error: error.message,
        stack: error.stack
      });
      throw error;
    }

    // Log credential status (without exposing actual keys)
    autoTradeLogger.log('Binance credentials retrieved', {
      userId,
      hasApiKey: !!credentials.apiKey,
      hasSecretKey: !!credentials.secretKey,
      apiKeyLength: credentials.apiKey ? credentials.apiKey.length : 0,
      secretKeyLength: credentials.secretKey ? credentials.secretKey.length : 0
    });

    // Get settings to retrieve the API URL
    const settings = await prisma.settings.findUnique({
      where: { userId }
    });

    // Use the configured API URL or default to Binance US
    const apiUrl = settings?.binanceTradeApi || 'https://api.binance.us/api/v3/order';
    const baseUrl = apiUrl.split('/api/')[0]; // Extract base URL (e.g., https://api.binance.us)
    const uriPath = apiUrl.substring(baseUrl.length); // Extract URI path (e.g., /api/v3/order)
    
    // Use test endpoint if explicitly requested or in test mode
    const endpoint = useTestEndpoint 
      ? '/api/v3/order/test' 
      : (testMode ? uriPath.replace('/order', '/order/test') : uriPath);

    // Log API URL configuration
    autoTradeLogger.log('Binance API URL configuration', {
      configuredApiUrl: settings?.binanceTradeApi || 'Not configured, using default',
      baseUrl,
      uriPath,
      endpoint,
      finalEndpoint: endpoint,
      testMode,
      useTestEndpoint
    });

    // Prepare request parameters - use current timestamp in milliseconds
    const timestamp = Date.now();

    // Validate required parameters before building the request
    if (!params.symbol) {
      throw new Error('Symbol is required and cannot be null or undefined');
    }
    
    if (!params.side) {
      throw new Error('Side is required and cannot be null or undefined');
    }
    
    if (!params.type) {
      throw new Error('Type is required and cannot be null or undefined');
    }
    
    if (params.quantity === undefined || params.quantity === null) {
      throw new Error('Quantity is required and cannot be null or undefined');
    }
    
    if (isNaN(params.quantity) || params.quantity <= 0) {
      throw new Error(`Invalid quantity: ${params.quantity}. Must be a positive number.`);
    }
    
    // DETAILED LOGGING: Log all parameters before building the request
    autoTradeLogger.log(`[${requestId}] Binance API parameters validation passed:`, {
      symbol: params.symbol,
      symbolType: typeof params.symbol,
      
      side: params.side,
      sideType: typeof params.side,
      
      type: params.type,
      typeType: typeof params.type,
      
      quantity: params.quantity,
      quantityType: typeof params.quantity,
      quantityIsNaN: isNaN(params.quantity),
      
      timestamp: timestamp,
      timestampType: typeof timestamp,
      
      timestamp: new Date().toISOString()
    });
    
    // Build the core parameters object with ONLY the fields required by Binance API
    // Required fields: symbol, side, type, quantity, timestamp
    const coreParams = {
      symbol: params.symbol,
      side: params.side,
      type: params.type,
      quantity: params.quantity.toString(),
      timestamp: timestamp.toString()
    };
    
    // Add ONLY essential optional parameters based on order type
    // For LIMIT orders, price and timeInForce are required
    if (params.type === 'LIMIT') {
      if (params.price) {
        coreParams['price'] = params.price.toString();
      }
      
      if (params.timeInForce) {
        coreParams['timeInForce'] = params.timeInForce;
      } else {
        // Default to GTC (Good Till Canceled) if not specified
        coreParams['timeInForce'] = 'GTC';
      }
    }
    
    // Add recvWindow parameter to prevent timestamp issues (this is a standard parameter)
    coreParams['recvWindow'] = '5000';
    
    // Log the constructed parameters object with emphasis on Binance API compliance
    autoTradeLogger.log(`[${requestId}] Binance API parameters constructed (STRICTLY PER API SPEC):`, {
      coreParams: JSON.stringify(coreParams),
      requiredFields: ['symbol', 'side', 'type', 'quantity', 'timestamp'],
      optionalFields: params.type === 'LIMIT' ? ['price', 'timeInForce'] : [],
      standardFields: ['recvWindow'],
      timestamp: new Date().toISOString()
    });
    
    // Generate the query string in the exact format required by Binance API
    const queryString = Object.entries(coreParams)
      .map(([key, value]) => {
        // Ensure value is never undefined or null before encoding
        const safeValue = value === undefined || value === null ? '' : String(value);
        return `${key}=${encodeURIComponent(safeValue)}`;
      })
      .join('&');
    
    // Log the exact query string that will be used for the signature
    autoTradeLogger.log(`[${requestId}] EXACT BINANCE API QUERY STRING:`, {
      queryString,
      queryStringLength: queryString.length,
      queryStringParts: queryString.split('&'),
      timestamp: new Date().toISOString()
    });
    
    // Generate signature using HMAC SHA256 with the exact query string
    const signature = generateSignature(queryString, credentials.secretKey);
    
    // Log the signature generation (without exposing the actual signature)
    autoTradeLogger.log(`[${requestId}] Binance signature generated:`, {
      signatureLength: signature.length,
      signatureFirstChars: signature.substring(0, 5) + '...',
      signatureLastChars: '...' + signature.substring(signature.length - 5),
      timestamp: new Date().toISOString()
    });

    // Log the request details (without sensitive information)
    autoTradeLogger.log(`[${requestId}] Sending Binance order request:`, {
      action: params.side,
      quantity: params.quantity,
      symbol: params.symbol,
      price: params.price || 'market price',
      orderType: params.type,
      timestamp: new Date().toISOString()
    });
    
    // Create the full URL with query string and signature
    const requestUrl = `${baseUrl}${endpoint}`;
    const fullUrl = `${requestUrl}?${queryString}&signature=${signature}`;
    
    // Log the final request URL (with signature partially masked for security)
    autoTradeLogger.log(`[${requestId}] FINAL BINANCE API REQUEST:`, {
      baseUrl,
      endpoint,
      fullUrl: fullUrl.replace(signature, signature.substring(0, 5) + '...' + signature.substring(signature.length - 5)),
      fullUrlLength: fullUrl.length,
      queryStringLength: queryString.length,
      signatureLength: signature.length,
      hasQueryString: fullUrl.includes('?'),
      hasSignature: fullUrl.includes('signature='),
      timestamp: new Date().toISOString()
    });
    
    // Make the request with the exact format required by Binance API
    autoTradeLogger.log(`[${requestId}] Initiating Binance API request:`, {
      method: 'POST',
      url: requestUrl,
      queryString: queryString + '&signature=' + signature.substring(0, 5) + '...',
      timestamp: new Date().toISOString()
    });

    let response;
    try {
      // Make the request with the API key in the header as required by Binance
      // For Binance API, we need to send the request to the base URL with the query string in the URL
      response = await fetch(fullUrl, {
        method: 'POST',
        headers: {
          'X-MBX-APIKEY': credentials.apiKey,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });
      
      // Log the response status
      autoTradeLogger.log(`[${requestId}] Binance API response received:`, {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        timestamp: new Date().toISOString()
      });
      
      // Log the raw response status
      autoTradeLogger.log('Binance API response received', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        headers: JSON.stringify(Object.fromEntries([...response.headers.entries()])),
        timestamp: new Date().toISOString()
      });
      
      // Log the exact request that was sent (with sensitive data masked)
      autoTradeLogger.log(`[${requestId}] BINANCE API EXACT REQUEST SENT`, {
        url: requestUrl,
        method: 'POST',
        headers: {
          'X-MBX-APIKEY': credentials.apiKey ? `${credentials.apiKey.substring(0, 5)}...` : 'not provided',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        queryParams: {
          symbol: coreParams.symbol,
          side: coreParams.side,
          type: coreParams.type,
          quantity: coreParams.quantity,
          timestamp: coreParams.timestamp,
          recvWindow: coreParams.recvWindow,
          price: coreParams.price || 'not provided',
          timeInForce: coreParams.timeInForce || 'not provided',
          newClientOrderId: coreParams.newClientOrderId || 'not provided',
          newOrderRespType: coreParams.newOrderRespType || 'not provided',
          signature: signature ? `${signature.substring(0, 5)}...` : 'not provided'
        },
        queryString: queryString,
        fullQueryString: `${queryString}&signature=${signature ? `${signature.substring(0, 5)}...` : 'not provided'}`,
        timestamp: new Date().toISOString()
      });
    } catch (fetchError) {
      // Log network-level errors
      autoTradeLogger.log('Binance API network error', {
        error: fetchError.message,
        stack: fetchError.stack,
        timestamp: new Date().toISOString()
      });
      throw new Error(`Network error when calling Binance API: ${fetchError.message}`);
    }

    // Get response as text first to handle potential JSON parse errors
    let responseText;
    try {
      responseText = await response.text();
      autoTradeLogger.log('Binance API response text received', {
        responseTextLength: responseText.length,
        responseTextSample: responseText.substring(0, 200) + (responseText.length > 200 ? '...' : ''),
        timestamp: new Date().toISOString()
      });
    } catch (textError) {
      autoTradeLogger.log('Error getting response text from Binance API', {
        error: textError.message,
        stack: textError.stack,
        timestamp: new Date().toISOString()
      });
      throw new Error(`Error reading Binance API response: ${textError.message}`);
    }
    
    let responseData;
    try {
      // Try to parse as JSON
      responseData = responseText ? JSON.parse(responseText) : null;
      
      // Add null check for responseData
      if (!responseData) {
        console.error('Null response data after parsing Binance API response');
        autoTradeLogger.log('Null response data from Binance API', {
          responseText: responseText ? responseText.substring(0, 200) : 'No response text',
          timestamp: new Date().toISOString()
        });
        throw new Error('Received null response from Binance API');
      }
      
      autoTradeLogger.log('Binance API response parsed successfully', {
        hasResponseData: !!responseData,
        responseDataType: responseData ? typeof responseData : 'null',
        isResponseDataArray: Array.isArray(responseData),
        responseDataKeys: responseData ? Object.keys(responseData) : [],
        timestamp: new Date().toISOString()
      });
    } catch (parseError) {
      console.error('Error parsing Binance API response:', parseError);
      autoTradeLogger.log(`Error parsing Binance API response: ${parseError.message}`, {
        responseText: responseText ? responseText.substring(0, 500) : 'No response text', // Log first 500 chars of response
        error: parseError.message,
        stack: parseError.stack,
        timestamp: new Date().toISOString()
      });
      throw new Error(`Failed to parse Binance API response: ${responseText ? (responseText.substring(0, 200) + (responseText.length > 200 ? '...' : '')) : 'Empty response'}`);
    }

    // Check for errors
    if (!response.ok) {
      const errorMessage = responseData?.msg || 'Unknown error';
      const errorCode = responseData?.code || 'UNKNOWN';
      
      // Log detailed error information
      console.error('Binance API error:', {
        status: response.status,
        statusText: response.statusText,
        errorCode,
        errorMessage,
        responseData
      });
      
      autoTradeLogger.log(`Binance API error (${errorCode}): ${errorMessage}`, {
        status: response.status,
        statusText: response.statusText,
        responseData: JSON.stringify(responseData),
        timestamp: new Date().toISOString()
      });
      
      throw new Error(`Binance API error (${errorCode}): ${errorMessage}`);
    }

    // Log success
    autoTradeLogger.log(`Binance order created successfully`, {
      responseData: JSON.stringify(responseData),
      timestamp: new Date().toISOString()
    });

    return responseData;
  } catch (error) {
    // Comprehensive error logging with request details
    autoTradeLogger.log(`[${requestId}] Error creating Binance order: ${error.message}`, {
      error: error.message,
      stack: error.stack,
      requestUrl: baseUrl ? `${baseUrl}${endpoint}` : 'URL not available',
      queryString: queryString || 'Query string not available',
      endpoint: endpoint || 'Endpoint not available',
      testMode,
      useTestEndpoint,
      timestamp: new Date().toISOString()
    });
    console.error(`[${requestId}] Error creating Binance order:`, error);
    throw error;
  }
}

/**
 * Format crypto symbol for Binance API
 * Removes any special characters and ensures proper format (e.g., BTC/USD -> BTCUSDT)
 */
export function formatBinanceSymbol(symbol: string): string {
  // Remove any special characters and convert to uppercase
  const cleanSymbol = symbol.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
  
  // If the symbol doesn't end with USDT, append it
  if (!cleanSymbol.endsWith('USDT')) {
    return `${cleanSymbol}USDT`;
  }
  
  return cleanSymbol;
}

/**
 * Execute a market buy order on Binance
 */
export async function executeBinanceMarketBuy(
  userId: string,
  symbol: string,
  quantity: number,
  testMode: boolean = false,
  useTestEndpoint: boolean = false
): Promise<any> {
  const formattedSymbol = formatBinanceSymbol(symbol);
  
  // Only include the required parameters for Binance API
  return createBinanceOrder(
    userId,
    {
      symbol: formattedSymbol,
      side: 'BUY',
      type: 'MARKET',
      quantity
    },
    testMode,
    useTestEndpoint
  );
}

/**
 * Execute a market sell order on Binance
 */
export async function executeBinanceMarketSell(
  userId: string,
  symbol: string,
  quantity: number,
  testMode: boolean = false,
  useTestEndpoint: boolean = false
): Promise<any> {
  const formattedSymbol = formatBinanceSymbol(symbol);
  
  // Only include the required parameters for Binance API
  return createBinanceOrder(
    userId,
    {
      symbol: formattedSymbol,
      side: 'SELL',
      type: 'MARKET',
      quantity
    },
    testMode,
    useTestEndpoint
  );
}

/**
 * Execute a limit buy order on Binance
 */
export async function executeBinanceLimitBuy(
  userId: string,
  symbol: string,
  quantity: number,
  price: number,
  testMode: boolean = false,
  useTestEndpoint: boolean = false
): Promise<any> {
  const formattedSymbol = formatBinanceSymbol(symbol);
  
  // Only include the required parameters for Binance API
  // For LIMIT orders: symbol, side, type, quantity, price, timeInForce
  return createBinanceOrder(
    userId,
    {
      symbol: formattedSymbol,
      side: 'BUY',
      type: 'LIMIT',
      quantity,
      price,
      timeInForce: 'GTC' // Good Till Canceled - required for LIMIT orders
    },
    testMode,
    useTestEndpoint
  );
}

/**
 * Execute a limit sell order on Binance
 */
export async function executeBinanceLimitSell(
  userId: string,
  symbol: string,
  quantity: number,
  price: number,
  testMode: boolean = false,
  useTestEndpoint: boolean = false
): Promise<any> {
  const formattedSymbol = formatBinanceSymbol(symbol);
  
  // Only include the required parameters for Binance API
  // For LIMIT orders: symbol, side, type, quantity, price, timeInForce
  return createBinanceOrder(
    userId,
    {
      symbol: formattedSymbol,
      side: 'SELL',
      type: 'LIMIT',
      quantity,
      price,
      timeInForce: 'GTC' // Good Till Canceled - required for LIMIT orders
    },
    testMode,
    useTestEndpoint
  );
}